* Kima
[[https://gitlab.com/michalis_pardalos/Kima/commits/master][[[https://gitlab.com/michalis_pardalos/Kima/badges/master/pipeline.svg]]]]
A Programming Language with static types and (currently WIP) algebraic
effects.

** Getting started
*** Installing
#+BEGIN_SRC sh
  git clone https://gitlab.com/michalis_pardalos/Kima.git
  cd Kima
  stack install
#+END_SRC

*** Usage
You can run a file with

#+BEGIN_SRC sh
  kima run example.k
#+END_SRC

or start the REPL with

#+BEGIN_SRC sh
  kima repl
#+END_SRC

any other options should be documented in

#+BEGIN_SRC sh
  kima --help
#+END_SRC

** Examples
Let's get the basic Hello World out of the way

#+BEGIN_SRC
  fun main() -> Unit {
      print("Hello World!");
  }
#+END_SRC

We can define our string as a local variable too:

#+BEGIN_SRC
  fun main() -> Unit {
      let output: String = "Hello World!";
      print(output);
  }
#+END_SRC

But there's no need to say the string is a String. Type inference takes
care of that!

#+BEGIN_SRC
  fun main() -> Unit {
      let output = "Hello World!";
      print(output);
  }
#+END_SRC

What if we changed out mind about the string we want to print?

#+BEGIN_SRC
  fun main() -> Unit {
      let output = "Hello World!";
      output = "Hello Everyone!"
      print(output);
  }
#+END_SRC

Oops! That's an error. =let= creates immutable variables. Use =var= for
mutable variables.

#+BEGIN_SRC
  fun main() -> Unit {
      var output = "Hello World!";
      output = "Hello Everyone!"
      print(output);
  }
#+END_SRC

That's better! We can also make a function to return a custom greeting

#+BEGIN_SRC
  fun greet(name: String) -> String {
      "Hello " + name;
  }

  fun main() -> Unit {
      let output = greet("everyone!");
      print(output);
  }
#+END_SRC

As you can see, functions return the value of the last statement in
their body.

Functions can also take functions as arguments or return them:

#+BEGIN_SRC
  fun adder(x: Int) -> (Int) -> Int {
      fun(y: Int) -> Int {
          x + y;
      }
  }

  fun main() -> {
      let add_3 = adder(3);
      print("3 + 5 = ");
      print(add_3(5));
  }
#+END_SRC

You can define data types like so:

#+BEGIN_SRC
  data Email(name: String, server: String, tld: String)

  fun to_string(email: Email) -> String {
      email.name + "@" + email.server + "." + email.tld;
  }

  fun main() -> Unit {
      print(to_string(Email("john.smith", "example", "com")));
  }
#+END_SRC

And more features are coming soon!

** TODO
- [X] Builtin types
- [X] Higher-order functions
- [X] Product types (records)
- [X] Type checking
- [X] Type inference (bidirectional typing takes care of both)
- [X] Control flow (if, while)
- [ ] Pattern matching
- [ ] Effect system
- [ ] Sum types
- [ ] Polymorphic types
- [ ] Source position annotations (better error messages)
