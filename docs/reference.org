#+TITLE: The Kima programming language
#+AUTHOR: Michail Pardalos
#+EMAIL: mpardalos@gmail.com

#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

* Constants and Variables
You can define variables using the ~var~ and constants using ~let~.
#+BEGIN_SRC
let x = 5;
var y = 3;
#+END_SRC

You can reassign variables using ~=~
#+BEGIN_SRC
y = 5;
#+END_SRC

Trying to reassign a constant declared with ~let~ will give a typechecking error
* Control Flow
Kima features minimal built-in control flow. Other, more complex control flow
constructs can be created using the [[Effects]] feature
** If
#+BEGIN_SRC
let x: Int = 5;

if (x < 10) {
    print("x is less than 10");
}

if (x == 5) {
    print("x=5");
} else if (x == 6) {
    print("x=6");
} else {
    print("x is not 5 or 6");
}
#+END_SRC

If in Kima functions as you would expect. Give an boolean expression and if it
evaluates to true then the body executes. If an else branch is given, then it is
executed if the condition is false.

The braces around the statements are not required. They are only there for
grouping. If the body only consists of a single statement then you can skip
them. For example, the two statements below are equivalent:
#+BEGIN_SRC
if (1 < 2) {
    print("1 < 2");
} else {
    print("1 > 2");
}

if (1 < 2)
    print("1 < 2");
else
    print("1 > 2");
#+END_SRC

Now, since an if is also a statement, we can use this to chain them into
else-ifs.
#+BEGIN_SRC
if (4 > 5) print("4 > 5");
else if (6 > 5) print("4 <=5 and 6 > 5");
else print("Neither is true")
#+END_SRC

** While
While statements, again are no surprise. The boolean expression is evaluated
when the while loop is first encountered, if it is true the body executes, then
we re-evaluate the expression, and if it is true, repeat.
#+BEGIN_SRC
while (true) {
    print("Printing forever");
}
#+END_SRC

Similarly to an if, we can skip the braces if the loop contains only a single
statement
#+BEGIN_SRC
while (true) print("Printing forever");
#+END_SRC

* Functions
You can define variables at the top level like so:
#+BEGIN_SRC
fun f(x: Int, y: String) -> Int {
    # code
    5;
}
#+END_SRC

The value returned by the last statement in the function body is returned by the
function.

Functions in Kima are *first-class objects*. This means they can be treated just
like any other value; assigned to variables, passed into other functions or
returned from functions.

You can define functions just like any other value as well.
#+BEGIN_SRC
let f = fun(x: Int) -> Int { x + 1; }
#+END_SRC

For a function defined locally like this, Kima can infer the return type so you
can skip declaring that.
#+BEGIN_SRC
let f = fun(x: Int) { x + 1; }
#+END_SRC
and Kima will still infer ~f: (Int) -> Int~

* Defining Types
New types are declared with the =data= keyword and they come in two flavours
** Records
You can declare records like so:
#+BEGIN_SRC
type Person(firstName: String, lastName: String, age: Int)
#+END_SRC

you can then create a value of that type
#+BEGIN_SRC
let p = Person("John", "Doe", 26)
#+END_SRC

and access its fields
#+BEGIN_SRC
p.firstName # "John"
#+END_SRC

if a variable is declared as (im)mutable then all its fields are also (im)mutable
#+BEGIN_SRC
let p1 = Person("John", "Doe", 26)
p.firstName = "Jane" # error

let p2 = Person("John", "Doe", 26)
p2.firstName = "Jane" # ok
p2.firstName # "Jane"
#+END_SRC

The first declaration introduces
+ A type named "Person"
+ A constructor called "Person" of type =(String, String, Int) -> Person=
+ [[Accessors][Accessors]] named =.firstname=, =.lastname=, and =.age=, of types =Person -> String=,
  =Person -> String= and =Person -> Int= respectively

** Enumerations
You can declare records like so:
#+BEGIN_SRC
type Result {
    Failure(),
    Success(value: Int)
}
#+END_SRC

you can then create a value of that type
#+BEGIN_SRC
let s: Result = Success(5);
let f: Result = Failure();
#+END_SRC

Unlike records, enumerations do not create accessors. It wouldn't be possible,
since fields could be missing! In this example, =s= has a =value=, but =f= does not,
so what would a hypothetical =.value= accessor return?

Since you can't access the contents of an enumeration directly, the only way is
to use [[Pattern Matching][Pattern Matching]]

The first declaration introduces
+ A type named "Person"
+ Constructors named =Failure= and =Success=, with types =() -> Result= and =Int ->
  Result=, respectively
+ *No* Accessors

** Polymorphic types (generics)
Types in Kima can be defined in terms of a number of type parameters. For
example, the =Result= type from before can be modified to be able to carry any
result value, not just integers:
#+BEGIN_SRC
type Numbered<t>(num: Int, val: t)
#+END_SRC

You can then instantiate that type when declaring a variable:
#+BEGIN_SRC
let x: Numbered<String> = Numbered(1, "hi");
#+END_SRC

Or it can be used in a function:
#+BEGIN_SRC
fun printIndex(val: Numbered<t>) -> Unit {
    print(val.num);
}
#+END_SRC

In the above declaration, the function *itself* actually takes =t= as a type
parameter. Kima can infer the type parameters however and so there is no need to
specify them. If you still want to however, you can do that:
#+BEGIN_SRC
fun printIndex<t>(val: Numbered<t>) -> Unit {
    print(val.num);
}
#+END_SRC


* Pattern Matching
Pattern matching can be used for a variety of purposes, like analysing (case
splitting) enumeration types, taking components from record types and even as a
simple switch statement.

Let's start with the last case, the simple switch statement. It would look like
this:
#+BEGIN_SRC
fun match_int(n: Int) -> Unit {
    match n {
        1: print("One");
        2: print("Two");
        _: print("Too much");
    }
}
#+END_SRC

Then, you can use it to do something depending on the value of an
enumeration-typed variable. Forgetting to include a case here would result in a
compilation error
#+BEGIN_SRC
type Result {
    Failure, Success(value: Int)
}

fun default_to_zero(res: Result) -> Int {
    match res {
        Failure: 0;
        Success(val): val;
    }
}
#+END_SRC

We can also nest patterns. Here we only execute the right-hand side whose
corresponding pattern (left-hand side) *exactly* matches the value we are
pattern matching on.
#+BEGIN_SRC
type Reason {
    Timeout,
    InvalidResponse,
    Other(msg: String)
}

type ExplainedResult {
    Success(val: Int),
    Failure(Reason)
}

fun prettyPrintResult(res: Result) -> {
    match res {
        Failure(Timeout): println("Error: The connection timed out");
        Failure(InvalidResponse): println("Error: Received an invalid response");
        Failure(Other(msg)): println("Error: " + msg);
        Success(val): println("Result: val");
    }
}
#+END_SRC

Finally, we can use pattern matching in a slightly different way to quickly
extract components of a record type.
#+BEGIN_SRC
type Person(firstName: String, lastName: String, age: Int)

fun printPerson(p: Person) {
    let Person(firstName, lastName, age) = p;
    print(firstName + lastName + ". Age " + toString(age));
}

# or

fun printPersonExplicit(p: Person) {
    match p {
        Person(firstName, lastName, age):
            print(firstName + lastName + ". Age " + toString(age));
    }
}
#+END_SRC
Trying to use the first form with an enumeration type with more than one constructor
will result in a compile-time error. If the value on the right-hand side is not
from the constructor you've given on the left then there is no way to fill out
the values that you've given on the right.

* Builtins
** Types
** Functions
* Effects
* Accessors
